<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Add viewport-fit=cover so safe-area insets work on iOS devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Internet Radio</title>
  <style>
    /*----------------------------------------*/
    /* 1) Prevent all scrolling/overflow       */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;           /* no scrolling at all */
      touch-action: none;         /* disable any touch‚Äêdrag/scroll */
      background-color: #311B0B;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
      box-sizing: border-box;
    }

    /*----------------------------------------*/
    /* 2) Blurred background image            */
    #bg-blur {
      position: absolute;
      inset: 0;                    /* top:0; right:0; bottom:0; left:0 */
      width: 100%;
      height: 100%;
      object-fit: cover;           /* cover the entire viewport */
      object-position: center;
      filter: blur(25px) brightness(0.7);
      pointer-events: none;
      z-index: 0;
      transition: opacity 0.5s ease;
    }

    /*----------------------------------------*/
    /* 3) Header + Safe‚ÄêArea Handling         */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 56px;                /* room for status bar + icons */
      pointer-events: none;
      z-index: 2;
    }
    #logo {
      position: absolute;
      top: calc(16px + env(safe-area-inset-top));
      left: calc(16px + env(safe-area-inset-left));
      font-size: 1.5rem;
      font-weight: 600;
      letter-spacing: 2px;
      pointer-events: auto;
      user-select: none;
      color: #fff;
    }
    #menu-btn {
      position: absolute;
      top: calc(16px + env(safe-area-inset-top));
      right: calc(64px + env(safe-area-inset-right));
      font-size: 1.5rem;
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
      outline: none;
      pointer-events: auto;
      user-select: none;
    }
    #stats-btn {
      position: absolute;
      top: calc(16px + env(safe-area-inset-top));
      right: calc(16px + env(safe-area-inset-right));
      font-size: 1.2rem;
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
      outline: none;
      pointer-events: auto;
      user-select: none;
      padding: 4px;
    }

    /*----------------------------------------*/
    /* 4) Menu Popup (below the button)       */
    #menu-popup {
      display: none;
      position: absolute;
      top: calc(56px + env(safe-area-inset-top));
      right: calc(64px + env(safe-area-inset-right));
      min-width: 180px;
      background: rgba(255, 255, 255, 0.96);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
      padding: 12px 16px;
      font-size: 1rem;
      color: #222;
      max-width: calc(100vw - 32px);
      z-index: 1000;
      animation: fadeIn 0.2s ease-out;
    }
    #menu-popup.active {
      display: block;
    }
    #menu-popup h3 {
      margin: 0 0 8px;
      font-size: 1.1rem;
      font-weight: 600;
    }

    /*----------------------------------------*/
    /* 5) Stats Panel (nerdy stats)           */
    #stats-panel {
      position: fixed;
      top: 0;
      right: -400px;
      width: 350px;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      color: #fff;
      padding: 20px;
      box-sizing: border-box;
      z-index: 2000;
      overflow-y: auto;
      transition: right 0.3s ease;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      line-height: 1.4;
      backdrop-filter: blur(10px);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
    }
    #stats-panel.active {
      right: 0;
    }
    #stats-panel h2 {
      margin: 0 0 20px;
      font-size: 1.2rem;
      color: #00ff00;
      text-align: center;
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
    }
    .stat-group {
      margin-bottom: 20px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .stat-group h3 {
      margin: 0 0 10px;
      color: #ffff00;
      font-size: 1rem;
    }
    .stat-item {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
      padding: 2px 0;
    }
    .stat-label {
      color: #ccc;
      flex: 1;
    }
    .stat-value {
      color: #00ff88;
      font-weight: bold;
      text-align: right;
      flex: 1;
    }
    .stat-value.warning {
      color: #ffaa00;
    }
    .stat-value.error {
      color: #ff4444;
    }
    #close-stats {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: #fff;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 5px;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    #close-stats:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /*----------------------------------------*/
    /* 6) Main content (centered, below header) */
    #main-content {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      padding-top: calc(56px + env(safe-area-inset-top));
      padding-bottom: calc(80px + env(safe-area-inset-bottom)); /* More space for controls */
      box-sizing: border-box;
      text-align: center;
      z-index: 1;
    }

    /* COVER CARD */
    #cover-card {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 32px rgba(0, 0, 0, 0.3);
      display: inline-flex;
      flex-direction: row;        /* default: side‚Äêby‚Äêside */
      align-items: center;
      gap: 20px;
      max-width: calc(90vw - 32px);
      box-sizing: border-box;
    }
    #album-cover {
      width: clamp(160px, 30vw, 280px);
      height: clamp(160px, 30vw, 280px);
      background: #333;
      border-radius: 12px;
      box-shadow: 0 2px 14px rgba(0, 0, 0, 0.5);
      object-fit: cover;
      object-position: center;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #ccc;
      font-size: 3rem;
      border: 3px solid #fff;
      overflow: hidden;
      position: relative;
    }
    #album-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    #album-cover img.visible {
      opacity: 1;
    }
    #details {
      display: flex;
      flex-direction: column;
      justify-content: center;
      color: #fff;
      text-align: left;
    }
    #song-title {
      font-size: clamp(1.5rem, 4vw, 2rem);
      font-weight: 700;
      margin: 0 0 8px;
      letter-spacing: 0.5px;
      line-height: 1.2;
    }
    #song-artist {
      font-size: clamp(1rem, 3vw, 1.2rem);
      font-weight: 400;
      margin: 0;
      opacity: 0.9;
    }

    /* Status indicator */
    #status-indicator {
      position: absolute;
      top: calc(70px + env(safe-area-inset-top));
      right: calc(16px + env(safe-area-inset-right));
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 500;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      z-index: 3;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    #status-indicator.show {
      opacity: 1;
    }
    #status-indicator.buffering {
      background: rgba(255, 165, 0, 0.8);
      color: #000;
    }
    #status-indicator.error {
      background: rgba(255, 0, 0, 0.8);
    }
    #status-indicator.reconnecting {
      background: rgba(0, 150, 255, 0.8);
    }
    #status-indicator.connected {
      background: rgba(0, 255, 0, 0.8);
      color: #000;
    }

    /*----------------------------------------*/
    /* 7) Bottom controls                     */
    #controls {
      position: absolute;
      bottom: calc(16px + env(safe-area-inset-bottom));
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      border-radius: 32px;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 16px;
      box-sizing: border-box;
      max-width: calc(100vw - 32px);
      z-index: 10;
    }
    #play-btn {
      width: clamp(40px, 8vw, 50px);
      height: clamp(40px, 8vw, 50px);
      background: #fff;
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      transition: background 0.2s;
      padding: 0;
      flex-shrink: 0;
    }
    #play-btn:hover {
      background: #eee;
    }
    #play-btn svg {
      width: clamp(18px, 4vw, 24px);
      height: clamp(18px, 4vw, 24px);
      fill: #311B0B;
    }
    #volume-slider {
      -webkit-appearance: none;
      width: clamp(80px, 20vw, 180px);
      height: 4px;
      background: #fff;
      border-radius: 2px;
      outline: none;
      cursor: pointer;
      flex-shrink: 1;
    }
    #volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #311B0B;
      cursor: pointer;
      box-shadow: 0 1px 5px rgba(0, 0, 0, 0.3);
    }
    #volume-slider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #311B0B;
      cursor: pointer;
      box-shadow: 0 1px 5px rgba(0, 0, 0, 0.3);
    }

    /*----------------------------------------*/
    /* 8) Portrait/mobile corrections          */
    @media only screen and (max-width: 600px) and (orientation: portrait) {
      /* Stack cover + details vertically */
      #cover-card {
        flex-direction: column;
        align-items: center;
      }
      #details {
        text-align: center;
        margin-top: 12px;
      }
      /* Tweak controls if desired */
      #controls {
        gap: 12px;
        padding: 8px 16px;
      }
      #volume-slider {
        width: 120px;
      }
      #stats-panel {
        width: 100vw;
        right: -100vw;
        padding: 15px;
      }
      #stats-panel h2 {
        font-size: 1.1rem;
        margin-bottom: 15px;
      }
      .stat-group {
        margin-bottom: 15px;
        padding: 8px;
      }
      .stat-item {
        margin: 3px 0;
        font-size: 0.8rem;
      }
    }

    /* IMPROVED LANDSCAPE MODE FOR PHONES */
    @media only screen and (max-width: 900px) and (orientation: landscape) {
      /* Smaller album cover to prevent crushing */
      #album-cover {
        width: clamp(80px, 15vw, 120px) !important;
        height: clamp(80px, 15vw, 120px) !important;
      }
      
      /* Adjust cover card for better spacing */
      #cover-card {
        max-width: calc(100vw - 64px);
        padding: 12px 16px;
        gap: 16px;
      }
      
      /* Smaller text for landscape */
      #song-title {
        font-size: clamp(1.2rem, 3vw, 1.6rem);
        margin: 0 0 4px;
      }
      #song-artist {
        font-size: clamp(0.9rem, 2.5vw, 1.1rem);
      }
      
      /* Adjust main content padding */
      #main-content {
        padding-top: calc(56px + env(safe-area-inset-top));
        padding-bottom: calc(70px + env(safe-area-inset-bottom));
      }
      
      /* Compact controls for landscape */
      #controls {
        bottom: calc(12px + env(safe-area-inset-bottom));
        gap: 10px;
        padding: 6px 12px;
      }
      #play-btn {
        width: 40px;
        height: 40px;
      }
      #play-btn svg {
        width: 18px;
        height: 18px;
      }
      #volume-slider {
        width: clamp(60px, 15vw, 100px);
      }
      
      /* MUCH SMALLER STATS PANEL FOR LANDSCAPE */
      #stats-panel {
        width: 280px;
        right: -280px;
        padding: 12px;
        font-size: 0.75rem;
      }
      #stats-panel h2 {
        font-size: 1rem;
        margin-bottom: 12px;
        padding-bottom: 8px;
      }
      .stat-group {
        margin-bottom: 12px;
        padding: 6px 8px;
      }
      .stat-group h3 {
        font-size: 0.9rem;
        margin-bottom: 6px;
      }
      .stat-item {
        margin: 2px 0;
        font-size: 0.75rem;
      }
      .stat-label {
        font-size: 0.7rem;
      }
      .stat-value {
        font-size: 0.75rem;
      }
      #close-stats {
        width: 25px;
        height: 25px;
        font-size: 1.2rem;
        top: 10px;
        right: 10px;
      }
      
      /* Make stats panel semi-transparent so content shows through */
      #stats-panel.active {
        background: rgba(0, 0, 0, 0.85);
      }
    }

    /* Extra small landscape phones (like when Galaxy Fold is closed) */
    @media only screen and (max-width: 600px) and (orientation: landscape) and (max-height: 400px) {
      #album-cover {
        width: 70px !important;
        height: 70px !important;
        font-size: 2rem;
      }
      #cover-card {
        padding: 8px 12px;
        gap: 12px;
      }
      #song-title {
        font-size: 1rem;
      }
      #song-artist {
        font-size: 0.8rem;
      }
      #controls {
        padding: 4px 8px;
        gap: 8px;
      }
      #play-btn {
        width: 36px;
        height: 36px;
      }
      #volume-slider {
        width: 60px;
      }
      
      /* TINY STATS PANEL FOR VERY SMALL LANDSCAPE */
      #stats-panel {
        width: 240px;
        right: -240px;
        padding: 8px;
        font-size: 0.7rem;
      }
      #stats-panel h2 {
        font-size: 0.9rem;
        margin-bottom: 8px;
      }
      .stat-group {
        margin-bottom: 8px;
        padding: 4px 6px;
      }
      .stat-group h3 {
        font-size: 0.8rem;
        margin-bottom: 4px;
      }
      .stat-item {
        margin: 1px 0;
        font-size: 0.65rem;
      }
      .stat-label {
        font-size: 0.6rem;
      }
      .stat-value {
        font-size: 0.65rem;
      }
      #close-stats {
        width: 20px;
        height: 20px;
        font-size: 1rem;
        top: 5px;
        right: 5px;
      }
    }

    /* Fade-in animation for menu popup */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-8px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <!-- 1) Blurred background -->
  <img id="bg-blur" src="" alt="Background Cover">

  <!-- 2) Header: logo (left) + menu button + stats button (right) -->
  <div id="header">
    <div id="logo">HaverokFM</div>
    <button id="menu-btn" aria-label="Open menu">&#9776;</button>
    <button id="stats-btn" aria-label="Show stats">üìä</button>
    <div id="menu-popup">
      <h3>About</h3>
      <p>This is an internet radio by haverok for haverok.<br>Made by Erik.</p>
    </div>
  </div>

  <!-- Stats Panel -->
  <div id="stats-panel">
    <button id="close-stats">√ó</button>
    <h2>üìä FAST RECONNECT</h2>
    
    <div class="stat-group">
      <h3>üåê Connection Monitor</h3>
      <div class="stat-item">
        <span class="stat-label">Monitoring:</span>
        <span class="stat-value" id="monitoring-active">No</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">DNS Status:</span>
        <span class="stat-value" id="dns-status">Not tested</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Ping Failures:</span>
        <span class="stat-value" id="ping-failures">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Fast Reconnects:</span>
        <span class="stat-value" id="reconnect-count">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Stream Reloads:</span>
        <span class="stat-value" id="reload-count">0</span>
      </div>
    </div>
    
    <div class="stat-group">
      <h3>üéµ Audio Stream</h3>
      <div class="stat-item">
        <span class="stat-label">Stream Status:</span>
        <span class="stat-value" id="stream-status">Stopped</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Audio Progress:</span>
        <span class="stat-value" id="audio-progress">0.0s</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Volume Level:</span>
        <span class="stat-value" id="volume-level">100%</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Buffer Length:</span>
        <span class="stat-value" id="buffer-length">0.0s</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Last Stall:</span>
        <span class="stat-value" id="last-stall">Never</span>
      </div>
    </div>
  </div>

  <!-- Status indicator -->
  <div id="status-indicator"></div>

  <!-- 3) Main content (centered, pushed below header) -->
  <div id="main-content">
    <div id="cover-card">
      <div id="album-cover">üìª</div>
      <div id="details">
        <div id="song-title"><b>Nincs duma (Csak zene)</b></div>
        <div id="song-artist">HaverokFM</div>
      </div>
    </div>
  </div>

  <!-- 4) Bottom controls (play/pause + volume) -->
  <div id="controls">
    <button id="play-btn" aria-label="Play/Pause">
      <svg id="play-icon" viewBox="0 0 64 64">
        <polygon points="16,8 56,32 16,56"></polygon>
      </svg>
      <svg id="pause-icon" viewBox="0 0 64 64" style="display:none">
        <rect x="16" y="12" width="12" height="40"></rect>
        <rect x="36" y="12" width="12" height="40"></rect>
      </svg>
    </button>
    <input id="volume-slider" type="range" min="0" max="1" step="0.01" value="1">
    
    <!-- Single audio element -->
    <audio id="audio" preload="auto"></audio>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const albumCoverEl = document.getElementById('album-cover');
      const bgBlurEl     = document.getElementById('bg-blur');
      const songTitleEl  = document.getElementById('song-title');
      const songArtistEl = document.getElementById('song-artist');
      const audio        = document.getElementById('audio');
      const playBtn      = document.getElementById('play-btn');
      const playIcon     = document.getElementById('play-icon');
      const pauseIcon    = document.getElementById('pause-icon');
      const volumeSlider = document.getElementById('volume-slider');
      const menuBtn      = document.getElementById('menu-btn');
      const menuPopup    = document.getElementById('menu-popup');
      const statusIndicator = document.getElementById('status-indicator');
      const statsBtn     = document.getElementById('stats-btn');
      const statsPanel   = document.getElementById('stats-panel');
      const closeStatsBtn = document.getElementById('close-stats');

      const coverUrl = "https://erik-server.ddns.net/image";
      const metaUrl  = "https://erik-server.ddns.net/metadata";
      const streamUrl = "https://erik-server.ddns.net/stream";
      const statusUrl = "https://erik-server.ddns.net/status";
      
      // Simple state management
      let isPlaying = false;
      let shouldBePlayingState = false;
      let monitoringActive = false;
      let reconnectCount = 0;
      let reloadCount = 0; // New counter for stream reloads
      let pingFailures = 0;
      let lastAudioProgress = 0;
      let dnsStatus = 'Not tested';
      let lastStallTime = null;
      let targetVolume = 1; // Remember target volume for fading
      let isReconnecting = false; // Prevent multiple reconnects
      let reconnectAttempts = 0; // Track consecutive reconnect attempts
      
      // Intervals
      let connectionCheckInterval = null;
      let progressCheckInterval = null;

      // Metadata management
      let lastSongData = { title: '', artist: '' };
      let lastCoverHash = '';

      // Set initial audio properties
      audio.src = streamUrl;
      audio.crossOrigin = "anonymous";
      audio.preload = "auto";
      audio.volume = volumeSlider.value;
      targetVolume = volumeSlider.value;

      // DNS ping to check connection
      function pingDNS() {
        const startTime = Date.now();
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 1000);
        
        fetch('https://dns.google/resolve?name=google.com&type=A', {
          method: 'GET',
          signal: controller.signal,
          cache: 'no-cache'
        }).then(response => {
          clearTimeout(timeoutId);
          if (response.ok) {
            dnsStatus = 'Online (' + (Date.now() - startTime) + 'ms)';
          } else {
            dnsStatus = 'DNS Error';
            handleConnectionFailure();
          }
          updateStats();
        }).catch(error => {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            dnsStatus = 'Timeout (>1000ms)';
          } else {
            dnsStatus = 'DNS Failed';
          }
          handleConnectionFailure();
          updateStats();
        });
      }

      function handleConnectionFailure() {
        pingFailures++;
        console.log('Connection failed, ping failures:', pingFailures);
        
        // If audio is playing and we detect connection issues
        if (shouldBePlayingState && isPlaying) {
          // Check if audio is actually progressing immediately
          setTimeout(() => checkAudioProgress(), 500); // Check faster
        }
      }

      function checkAudioProgress() {
        if (!shouldBePlayingState || audio.paused || isReconnecting) return;
        
        const currentProgress = audio.currentTime;
        const hasProgressed = Math.abs(currentProgress - lastAudioProgress) > 0.05; // More sensitive detection
        
        if (hasProgressed) {
          lastAudioProgress = currentProgress;
          reconnectAttempts = 0; // Reset attempts when audio is working
        } else {
          // Audio not progressing - ultra-fast reconnect
          console.log('Audio stopped progressing, ultra-fast reconnecting...');
          fastReconnect();
        }
        
        updateStats();
      }

      function fastReconnect() {
        // Prevent multiple reconnects running at same time
        if (isReconnecting) {
          console.log('Reconnect already in progress, skipping...');
          return;
        }
        
        isReconnecting = true;
        reconnectCount++;
        reconnectAttempts++;
        lastStallTime = Date.now();
        
        console.log(`Starting ultra-fast reconnect #${reconnectAttempts}...`);
        showStatus('Reconnecting...', 'reconnecting');
        
        // If too many attempts, wait longer before trying
        if (reconnectAttempts > 3) {
          console.log('Multiple reconnect attempts, waiting longer...');
          setTimeout(() => {
            doReconnect();
          }, 2000);
        } else {
          doReconnect();
        }
      }
      
      function doReconnect() {
        // Stop and reload the stream
        audio.pause();
        audio.currentTime = 0;
        audio.load();
        
        // Try to start playing again
        audio.play().then(() => {
          console.log('Ultra-fast reconnect successful');
          isReconnecting = false;
          reconnectAttempts = 0; // Reset attempts on success
          showStatus('Reconnected!', 'connected');
          
          // Jump to live after a moment
          setTimeout(() => jumpToLive(), 1000);
          
        }).catch(e => {
          console.error('Reconnect failed:', e);
          showStatus('Reconnect failed, retrying...', 'error');
          
          // Allow another reconnect attempt after delay
          setTimeout(() => {
            isReconnecting = false;
            if (shouldBePlayingState && reconnectAttempts < 5) {
              fastReconnect();
            } else if (reconnectAttempts >= 5) {
              console.log('Too many reconnect attempts, stopping...');
              showStatus('Connection problems, please try again', 'error');
              reconnectAttempts = 0;
              isReconnecting = false;
            }
          }, reconnectAttempts * 1000); // Exponential backoff
        });
      }

      // NEW FUNCTION: Force reload stream to get latest content
      function reloadStreamToLive() {
        console.log('Reloading stream to get latest content...');
        reloadCount++;
        showStatus('Loading live stream...', 'reconnecting');
        
        // Stop current playback
        audio.pause();
        audio.currentTime = 0;
        
        // Force reload by adding cache-busting parameter
        const cacheBuster = '?t=' + Date.now();
        audio.src = streamUrl + cacheBuster;
        audio.load();
        
        // Start playing the fresh stream
        audio.play().then(() => {
          console.log('Stream reloaded successfully, now live!');
          showStatus('Live stream loaded!', 'connected');
          
          // No need to jump to live since we're loading fresh
          // But we can still do it after a short delay to ensure we're at the very edge
          setTimeout(() => jumpToLive(), 500);
          
        }).catch(e => {
          console.error('Stream reload failed:', e);
          showStatus('Failed to load live stream', 'error');
          
          // Fallback to regular stream URL
          audio.src = streamUrl;
          audio.load();
          audio.play().catch(err => {
            console.error('Fallback also failed:', err);
          });
        });
        
        updateStats();
      }

      function fadeOut(callback) {
        const startVolume = audio.volume;
        const fadeTime = 300; // 300ms fade out
        const steps = 15;
        const volumeStep = startVolume / steps;
        const timeStep = fadeTime / steps;
        
        let currentStep = 0;
        const fadeInterval = setInterval(() => {
          currentStep++;
          audio.volume = Math.max(0, startVolume - (volumeStep * currentStep));
          
          if (currentStep >= steps) {
            clearInterval(fadeInterval);
            audio.volume = 0;
            if (callback) callback();
          }
        }, timeStep);
      }

      function fadeIn() {
        const fadeTime = 400; // 400ms fade in
        const steps = 20;
        const volumeStep = targetVolume / steps;
        const timeStep = fadeTime / steps;
        
        audio.volume = 0;
        let currentStep = 0;
        
        const fadeInterval = setInterval(() => {
          currentStep++;
          audio.volume = Math.min(targetVolume, volumeStep * currentStep);
          
          if (currentStep >= steps) {
            clearInterval(fadeInterval);
            audio.volume = targetVolume;
          }
        }, timeStep);
      }

      function jumpToLive() {
        if (!audio.buffered.length) {
          console.log('No buffer yet, will try jump to live again...');
          setTimeout(() => jumpToLive(), 1000);
          return;
        }
        
        try {
          const bufferedEnd = audio.buffered.end(audio.buffered.length - 1);
          const currentTime = audio.currentTime;
          
          // Force jump to the very end of the buffer (live edge)
          const livePosition = bufferedEnd - 0.5; // Just 0.5 seconds from live edge
          
          console.log(`Jumping to live: current=${currentTime.toFixed(1)}s, buffer=${bufferedEnd.toFixed(1)}s, jumping to=${livePosition.toFixed(1)}s`);
          
          if (livePosition > currentTime) {
            audio.currentTime = livePosition;
            console.log('Jumped to live stream position');
          } else {
            console.log('Already at live position');
          }
        } catch (e) {
          console.error('Jump to live failed:', e);
          // Try again in a moment
          setTimeout(() => jumpToLive(), 1000);
        }
      }

      function startMonitoring() {
        if (monitoringActive) return;
        
        console.log('Starting connection monitoring...');
        monitoringActive = true;
        
        // Start DNS ping every 500ms
        connectionCheckInterval = setInterval(() => {
          pingDNS();
        }, 500);
        
        // Start audio progress checking every 500ms (faster detection)
        progressCheckInterval = setInterval(() => {
          checkAudioProgress();
        }, 500);
        
        updateStats();
      }

      function stopMonitoring() {
        console.log('Stopping connection monitoring...');
        monitoringActive = false;
        
        if (connectionCheckInterval) {
          clearInterval(connectionCheckInterval);
          connectionCheckInterval = null;
        }
        
        if (progressCheckInterval) {
          clearInterval(progressCheckInterval);
          progressCheckInterval = null;
        }
        
        updateStats();
      }

      function updateStats() {
        document.getElementById('monitoring-active').textContent = monitoringActive ? 'Yes' : 'No';
        document.getElementById('monitoring-active').className = 'stat-value ' + (monitoringActive ? '' : 'warning');
        
        document.getElementById('dns-status').textContent = dnsStatus;
        document.getElementById('dns-status').className = 'stat-value ' + (dnsStatus.includes('Online') ? '' : 'error');
        
        document.getElementById('ping-failures').textContent = pingFailures;
        document.getElementById('reconnect-count').textContent = reconnectCount;
        document.getElementById('reload-count').textContent = reloadCount; // New stat
        
        document.getElementById('stream-status').textContent = !audio.paused ? 'Playing' : 'Stopped';
        document.getElementById('audio-progress').textContent = lastAudioProgress.toFixed(1) + 's';
        document.getElementById('volume-level').textContent = Math.round(audio.volume * 100) + '%';
        
        // Buffer stats
        if (audio.buffered.length > 0) {
          const bufferedEnd = audio.buffered.end(audio.buffered.length - 1);
          const bufferLength = bufferedEnd - audio.currentTime;
          document.getElementById('buffer-length').textContent = bufferLength.toFixed(1) + 's';
        } else {
          document.getElementById('buffer-length').textContent = '0.0s';
        }
        
        if (lastStallTime) {
          const stallAgo = Math.floor((Date.now() - lastStallTime) / 1000);
          document.getElementById('last-stall').textContent = stallAgo + 's ago';
        }
      }

      function showStatus(message, type = '') {
        statusIndicator.textContent = message;
        statusIndicator.className = `show ${type}`;
        setTimeout(() => {
          statusIndicator.classList.remove('show');
        }, 3000);
      }

      function setAlbumCover(src, forceUpdate = false) {
        if (!albumCoverEl || !bgBlurEl) return;
        
        const currentHash = Date.now().toString();
        if (!forceUpdate && lastCoverHash === currentHash) return;
        
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const existingImages = albumCoverEl.querySelectorAll('img');
          
          const newImg = img.cloneNode();
          newImg.style.width = "100%";
          newImg.style.height = "100%";
          newImg.style.objectFit = "cover";
          newImg.style.borderRadius = "12px";
          newImg.style.opacity = "0";
          newImg.style.transition = "opacity 0.5s ease";
          
          albumCoverEl.appendChild(newImg);
          albumCoverEl.style.fontSize = '0';
          
          setTimeout(() => {
            newImg.style.opacity = "1";
          }, 50);
          
          existingImages.forEach(oldImg => {
            oldImg.style.opacity = "0";
            setTimeout(() => {
              if (oldImg.parentNode) oldImg.remove();
            }, 500);
          });
          
          bgBlurEl.style.opacity = '0.5';
          setTimeout(() => {
            bgBlurEl.src = src + '?cache=' + currentHash;
            bgBlurEl.style.opacity = '1';
          }, 250);
          
          lastCoverHash = currentHash;
        };
        img.onerror = () => {
          const existingImages = albumCoverEl.querySelectorAll('img');
          existingImages.forEach(img => {
            img.style.opacity = "0";
            setTimeout(() => {
              if (img.parentNode) img.remove();
            }, 500);
          });
          
          setTimeout(() => {
            albumCoverEl.style.fontSize = '3rem';
            albumCoverEl.textContent = "üìª";
            bgBlurEl.style.opacity = '0';
          }, 500);
        };
        img.src = src + '?cache=' + currentHash;
      }

      async function fetchMetadata() {
        try {
          const response = await fetch(metaUrl + '?cache=' + Date.now());
          const txt = await response.text();
          let song = "Nincs duma (Csak zene)";
          let artist = "HaverokFM";

          try {
            const j = JSON.parse(txt);
            if (j.artist && j.title) {
              artist = j.artist;
              song = j.title;
            } else if (j.song) {
              const parts = j.song.split('#');
              if (parts.length === 2) {
                artist = parts[0];
                song = parts[1];
              }
            }
          } catch {
            if (txt.includes("#")) {
              const parts = txt.split("#");
              artist = parts[0].trim();
              song = parts[1].trim();
            } else if (txt.trim() && txt.trim() !== '') {
              const parts = txt.trim().split(/\s+/);
              artist = parts.shift();
              song = parts.join(' ') || txt.trim();
            }
          }

          const currentSongData = { title: song, artist: artist };
          const songChanged = (
            lastSongData.title !== currentSongData.title || 
            lastSongData.artist !== currentSongData.artist
          );

          if (songChanged) {
            const displaySong = song.replace(/\s*\(/g, "<br>(");
            songTitleEl.innerHTML = `<b>${displaySong}</b>`;
            songArtistEl.textContent = artist;

            setAlbumCover(coverUrl, true);

            if ("mediaSession" in navigator) {
              navigator.mediaSession.metadata = new MediaMetadata({
                title: song,
                artist: artist,
                album: "",
                artwork: [
                  {
                    src: coverUrl + '?cache=' + Date.now(),
                    sizes: '512x512',
                    type: 'image/png'
                  }
                ]
              });
            }

            lastSongData = currentSongData;
          }
        } catch (e) {
          console.error('Metadata fetch error:', e);
        }
      }

      function togglePlay() {
        if (audio.paused) {
          shouldBePlayingState = true;
          
          // IMPORTANT: Always reload stream when resuming to get latest content
          console.log('Play button pressed - reloading stream to get latest content');
          reloadStreamToLive();
          startMonitoring();
          
        } else {
          shouldBePlayingState = false;
          
          // Fade out when stopping
          fadeOut(() => {
            audio.pause();
            audio.volume = targetVolume; // Reset volume for next play
            console.log('Audio paused, stopping monitoring...');
            stopMonitoring();
          });
        }
      }

      // Audio event listeners
      audio.addEventListener('play', () => {
        playIcon.style.display = 'none';
        pauseIcon.style.display = 'block';
        isPlaying = true;
        
        // Fade in when starting to play
        fadeIn();
        
        if ("mediaSession" in navigator) {
          navigator.mediaSession.playbackState = "playing";
        }
      });

      audio.addEventListener('pause', () => {
        playIcon.style.display = 'block';
        pauseIcon.style.display = 'none';
        isPlaying = false;
        
        if ("mediaSession" in navigator) {
          navigator.mediaSession.playbackState = "paused";
        }
      });

      audio.addEventListener('error', (e) => {
        console.error('Audio error:', e);
        if (shouldBePlayingState) {
          showStatus('Stream error, reconnecting...', 'error');
          fastReconnect();
        }
      });

      audio.addEventListener('waiting', () => {
        showStatus('Buffering...', 'buffering');
      });

      audio.addEventListener('stalled', () => {
        console.log('Audio stalled');
        if (shouldBePlayingState) {
          setTimeout(() => checkAudioProgress(), 2000);
        }
      });

      // Control event listeners
      playBtn.addEventListener('click', togglePlay);
      volumeSlider.addEventListener('input', e => {
        targetVolume = parseFloat(e.target.value);
        audio.volume = targetVolume;
      });

      // Stats panel controls
      statsBtn.addEventListener('click', e => {
        statsPanel.classList.toggle('active');
        e.stopPropagation();
      });
      
      closeStatsBtn.addEventListener('click', () => {
        statsPanel.classList.remove('active');
      });

      // Media Session handlers
      if ("mediaSession" in navigator) {
        navigator.mediaSession.setActionHandler('play', () => {
          shouldBePlayingState = true;
          console.log('Media session play - reloading stream');
          reloadStreamToLive();
          startMonitoring();
        });
        
        navigator.mediaSession.setActionHandler('pause', () => {
          shouldBePlayingState = false;
          fadeOut(() => {
            audio.pause();
            audio.volume = targetVolume;
            stopMonitoring();
          });
        });
      }

      // Auto-start functionality
      function forceAutoPlay() {
        shouldBePlayingState = true;
        
        setTimeout(() => {
          console.log('Auto-play starting - loading fresh stream');
          reloadStreamToLive();
          startMonitoring();
        }, 100);
      }
      
      function setupInteractionFallback() {
        const startOnInteraction = (e) => {
          if (!isPlaying && shouldBePlayingState) {
            console.log('Starting on user interaction - reloading stream');
            reloadStreamToLive();
            startMonitoring();
          }
          document.removeEventListener('click', startOnInteraction);
          document.removeEventListener('touchstart', startOnInteraction);
          document.removeEventListener('keydown', startOnInteraction);
        };
        
        document.addEventListener('click', startOnInteraction);
        document.addEventListener('touchstart', startOnInteraction);
        document.addEventListener('keydown', startOnInteraction);
      }

      // Initialize
      setAlbumCover(coverUrl, true);
      fetchMetadata();
      updateStats();
      
      // Try auto-play, but if it fails, set up interaction fallback
      forceAutoPlay();
      setupInteractionFallback();
      
      // Only metadata updates run continuously
      setInterval(fetchMetadata, 4000);
      setInterval(updateStats, 1000);

      // Menu functionality
      menuBtn.addEventListener('click', e => {
        menuPopup.classList.toggle('active');
        statsPanel.classList.remove('active');
        e.stopPropagation();
      });
      
      window.addEventListener('click', (e) => {
        if (!statsPanel.contains(e.target) && !statsBtn.contains(e.target)) {
          statsPanel.classList.remove('active');
        }
        if (!menuPopup.contains(e.target) && !menuBtn.contains(e.target)) {
          menuPopup.classList.remove('active');
        }
      });
      
      menuPopup.addEventListener('click', e => e.stopPropagation());
      statsPanel.addEventListener('click', e => e.stopPropagation());
    });
  </script>
</body>
</html>
